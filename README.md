# Решение

## Выполненные требования

### Обязательные:
- проект должен быть выложен на GitHub и открываться с помощьюм VS2022
- в readme.md репозитория или на выделенной онлайн странице должно быть описание API

### Опциональные:
- API должно быть опубликовано в интернет (API доступно по ссылке https://galaur.ru/api , swagger : https://galaur.ru/swagger/index.html )
- проект собирается в докер и разворачиватся в рабочее состояние docker-compose (частично, без SSL-сертификата и файла настроек nginx сервер не поднимется)

## Описание Web API

### 1. SignalR
Так как это сетевая игра, придется отправлять частые запросы для отслеживания хода второго игрока. Чтобы избежать этого и отправлять данные, не дожидаясь запроса к серверу, понадобится установить и использовать клиентскую библиотеку SignalR.

**Необходимо установить соединение с сервером и сохранить Id соедиения для будущих запросов** 
 
Пример установки соединения на js:
```js
// Создаем экземпляр объекта SignalR с указанием адреса сервера
const connection = new signalR.HubConnectionBuilder()
    .withUrl("/api/gamehub")
    .build();
    
// Выполняем подключение к серверу и сохраняем идентификатор соединения
connection.start()
    .then(() => {
        console.log("Connected successfully!");
        const connectionId = connection.connectionId;
        console.log(`Connection ID: ${connectionId}`);
        // Теперь можно использовать идентификатор соединения в запросах к серверу
    })
    .catch((error) => {
        console.error(error);
    });
```

**Для получения данных с сервера надо зарегистрировать обработчики вызова метода**
Допустим, вызывается метод *receiveMessage* c параметрами *user* и *message*, то пример обработки будет таким:

```js
connection.on("receiveMessage", (user, message) => {
    console.log(`${user} says ${message}`);
});
```

**Методы, вызов которых нужно обработать:**

1. *playerJoined*(string message) - информирует о присоединение второго игрока к лобби.
2. *playerDisconnected*( model ) - информирует о выходе одного из игроков.

    Входящие данные:
    ```cs
    {
        message : string,
        scores : []
    }
    
    class score // счет игрока
    {
        Victories int,
        LobbyId string,
        PlayerId string,
    }
    ```
3. *receiveGame* (model, message) - получение id игры, счета и сообщения
    
    *model* состоит из:
    - `game` - модель созданной игры
    - `scores` - список счетов игроков
    
    *game* состоит из:
    - `Id` - идентификатор игры
    - `Winner` - победитель
    - `MoveOwnerId` - владелец хода. В начале игры определяет, кто ходит первым.
    
4. *madeMove*(moveResult) - информирует о сделанном ходе противника

    *MoveResult* состоит из:
    
    - `Move` - сделанный ход противника
    - `WinningsMove` (list<move>)- список выигрышных ходов противника, если противник не выиграл, поле пустое.
    - `Errors` (string) - возникшие ошибки при выполнении хода. Не придется обрабатывать.
    - `isDraw` (bool) - ничья или нет.
    
    *Move* состоит из:
    - `PlayerId` (string) - id игрока, выполнившего ход.
    - `X` (int) - координата x.
    - `Y` (int) - координата y.
    - `GameId` (string) - id текущей игры.